<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Python Code Display</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            white-space: pre-wrap; /* Wraps lines */
            font-family: Consolas, monospace;
        }
        .main-button {
            display: block;
            width: 120px;
            margin: 20px auto;
            padding: 10px;
            text-align: center;
            background-color: #007bff;
            color: #fff;
            border-radius: 5px;
            text-decoration: none;
        }
    </style>
</head>
<a href="index.html" class="main-button">Main Page</a>
<a href="project_description.html" class="main-button">Project Description Page</a>
<body>
    <h1>Python Code</h1>
    <pre>
<code>
# Példa Python kód
import pandas as pd
from sklearn.preprocessing import StandardScaler
from torch import nn, optim
import torch

# Adatbetöltés és előkészítés
dataset = load_dataset("EddyGiusepe/Modified_dataset_for_predictive_maintenance")
data = dataset['train'].to_pandas()
print(data.head())

# Adat normalizálás
features = data.drop(columns=['Failure Type'])
scaler = StandardScaler()
features = scaler.fit_transform(features)

# Adatok tanító és teszt halmazra osztása
X_train, X_test = train_test_split(features, test_size=0.2, random_state=42)
X_train = torch.tensor(X_train, dtype=torch.float32)
X_test = torch.tensor(X_test, dtype=torch.float32)

# Autoencoder modell definiálása
class Autoencoder(nn.Module):
    def __init__(self, input_dim):
        super(Autoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 16)
        )
        self.decoder = nn.Sequential(
            nn.Linear(16, 32),
            nn.ReLU(),
            nn.Linear(32, 64),
            nn.ReLU(),
            nn.Linear(64, input_dim)
        )

    def forward(self, x):
        encoded = self.encoder(x)
        decoded = self.decoder(encoded)
        return decoded

# Modell inicializálása
input_dim = X_train.shape[1]
model = Autoencoder(input_dim)

# Loss függvény és optimalizáló definiálása
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Modell tanítása
num_epochs = 50
for epoch in range(num_epochs):
    optimizer.zero_grad()
    outputs = model(X
