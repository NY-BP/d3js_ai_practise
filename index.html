<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Meghibásodások Típusonként és További Grafikonok</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    .chart { margin-top: 20px; }
    .node { stroke: #999; stroke-opacity: 0.6; }
    .link { fill: none; stroke: #666; stroke-width: 1.5px; }
  </style>
</head>
<body>
  <h2>Meghibásodások Típusonként</h2>
  <div id="barChart" class="chart"></div>
  
  <h2>Lég- és Folyamat Hőmérséklet Idősor</h2>
  <div id="lineChart" class="chart"></div>
  
  <h2>Forgási Sebesség és Forgatónyomaték Pontdiagram</h2>
  <div id="scatterPlot" class="chart"></div>

  <h2>Kapcsolatok a Bundle Diagramon</h2>
  <div id="bundleChart" class="chart"></div>

  <script>
    // Adatok betöltése és vizualizációk létrehozása
    d3.csv("data.csv").then(data => {
      data.forEach(d => {
        d["Air temperature [K]"] = +d["Air temperature [K]"];
        d["Process temperature [K]"] = +d["Process temperature [K]"];
        d["Rotational speed [rpm]"] = +d["Rotational speed [rpm]"];
        d["Torque [Nm]"] = +d["Torque [Nm]"];
      });

      // 1. Oszlopdiagram (Meghibásodások Típusonként)
      const failureCounts = d3.rollups(data, v => v.length, d => d["Failure Type"]);
      const margin = {top: 20, right: 30, bottom: 40, left: 90};
      const width = 600 - margin.left - margin.right;
      const height = 400 - margin.top - margin.bottom;

      const svgBar = d3.select("#barChart")
                        .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform", `translate(${margin.left},${margin.top})`);

      const xBar = d3.scaleBand()
                    .domain(failureCounts.map(d => d[0]))
                    .range([0, width])
                    .padding(0.2);

      svgBar.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(xBar))
            .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end");

      const yBar = d3.scaleLinear()
                    .domain([0, d3.max(failureCounts, d => d[1])])
                    .range([height, 0]);

      svgBar.append("g")
            .call(d3.axisLeft(yBar));

      svgBar.selectAll("rect")
            .data(failureCounts)
            .enter()
            .append("rect")
            .attr("x", d => xBar(d[0]))
            .attr("y", d => yBar(d[1]))
            .attr("width", xBar.bandwidth())
            .attr("height", d => height - yBar(d[1]))
            .attr("fill", "#69b3a2");

      svgBar.selectAll(".text")
            .data(failureCounts)
            .enter()
            .append("text")
            .attr("x", d => xBar(d[0]) + xBar.bandwidth() / 2)
            .attr("y", d => yBar(d[1]) - 5)
            .attr("text-anchor", "middle")
            .text(d => d[1]);

      // 2. Vonaldiagram (Lég- és Folyamat Hőmérséklet)
      const svgLine = d3.select("#lineChart")
                         .append("svg")
                         .attr("width", width + margin.left + margin.right)
                         .attr("height", height + margin.top + margin.bottom)
                         .append("g")
                         .attr("transform", `translate(${margin.left},${margin.top})`);

      const xLine = d3.scaleLinear()
                      .domain([0, data.length])
                      .range([0, width]);

      const yLine = d3.scaleLinear()
                      .domain([d3.min(data, d => Math.min(d["Air temperature [K]"], d["Process temperature [K]"])), 
                               d3.max(data, d => Math.max(d["Air temperature [K]"], d["Process temperature [K]"]))])
                      .range([height, 0]);

      svgLine.append("g")
             .attr("transform", `translate(0,${height})`)
             .call(d3.axisBottom(xLine).ticks(5));

      svgLine.append("g")
             .call(d3.axisLeft(yLine));

      const lineAir = d3.line()
                        .x((d, i) => xLine(i))
                        .y(d => yLine(d["Air temperature [K]"]));

      const lineProcess = d3.line()
                            .x((d, i) => xLine(i))
                            .y(d => yLine(d["Process temperature [K]"]));

      svgLine.append("path")
             .datum(data)
             .attr("fill", "none")
             .attr("stroke", "steelblue")
             .attr("stroke-width", 1.5)
             .attr("d", lineAir);

      svgLine.append("path")
             .datum(data)
             .attr("fill", "none")
             .attr("stroke", "orange")
             .attr("stroke-width", 1.5)
             .attr("d", lineProcess);

      // 3. Pontdiagram (Forgási Sebesség és Forgatónyomaték)
      const svgScatter = d3.select("#scatterPlot")
                           .append("svg")
                           .attr("width", width + margin.left + margin.right)
                           .attr("height", height + margin.top + margin.bottom)
                           .append("g")
                           .attr("transform", `translate(${margin.left},${margin.top})`);

      const xScatter = d3.scaleLinear()
                         .domain([d3.min(data, d => d["Rotational speed [rpm]"]), d3.max(data, d => d["Rotational speed [rpm]"])])
                         .range([0, width]);

      svgScatter.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScatter));

      const yScatter = d3.scaleLinear()
                         .domain([d3.min(data, d => d["Torque [Nm]"]), d3.max(data, d => d["Torque [Nm]"])])
                         .range([height, 0]);

      svgScatter.append("g")
                .call(d3.axisLeft(yScatter));

      svgScatter.append('g')
                .selectAll("dot")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", d => xScatter(d["Rotational speed [rpm]"]))
                .attr("cy", d => yScatter(d["Torque [Nm]"]))
                .attr("r", 3)
                .style("fill", "#69b3a2");
    });

    // 4. Bundle Diagram adatok betöltése külön
    d3.json("bundle_data.json").then(data => {
      const width = 600, height = 600;
      const svgBundle = d3.select("#bundleChart")
                         .append("svg")
                         .attr("width", width)
                         .attr("height", height)
                         .append("g")
                         .attr("transform", `translate(${width / 2},${height / 2})`);

      const cluster = d3.cluster()
                        .size([2 * Math.PI, width / 2 - 100]);

      const line = d3.lineRadial()
                     .curve(d3.curveBundle.beta(0.85))
                     .radius(d => d.y)
                     .angle(d => d.x);

      const root = packageHierarchy(data)
                      .sum(d => d.size);
      
      cluster(root);

      const link = svgBundle.append("g").selectAll(".link")
                            .data(packageImports(root.leaves()))
                            .enter().append("path")
                            .attr("class", "link")
                            .attr("d", d => {
                              if (d.source && d.target) {
                                return line(d.source.path(d.target));
                              } else {
                                console.warn("Undefined path: ", d);
                                return null;
                              }
                            });

      const node = svgBundle.append("g").selectAll(".node")
                            .data(root.leaves())
                            .enter().append("text")
                            .attr("class", "node")
                            .attr("dy", "0.31em")
                            .attr("transform", d => `rotate(${d.x * 180 / Math.PI - 90})translate(${d.y},0)${d.x < Math.PI ? "" : "rotate(180)"}`)
                            .attr("text-anchor", d => d.x < Math.PI ? "start" : "end")
                            .text(d => d.data.key);
    });

    function packageHierarchy(classes) {
      const map = {};
      function find(name, data) {
        let node = map[name];
        if (!node) {
          node = map[name] = data || { name: name, children: [] };
          if (name.length) {
            const i = name.lastIndexOf(".");
            node.parent = find(name.substring(0, i));
            node.parent.children.push(node);
            node.key = name.substring(i + 1);
          }
        }
        return node;
      }
      classes.forEach(d => find(d.name, d));
      return d3.hierarchy(map[""]);
    }

    function packageImports(nodes) {
      const map = {};
      const imports = [];
      nodes.forEach(d => map[d.data.name] = d);
      nodes.forEach(d => {
        if (d.data.imports) {
          d.data.imports.forEach(i => {
            if (map[i]) {
              imports.push({source: map[d.data.name], target: map[i]});
            } else {
              console.warn(`Missing target node for import: ${i}`);
            }
          });
        }
      });
      return imports;
    }
  </script>
</body>
</html>
